# ==============================================================================
# КОНФИГУРАЦИЯ ПРОЕКТА И ИНСТРУМЕНТОВ РАЗРАБОТКИ
# ==============================================================================
#
# pyproject.toml — современный стандарт (PEP 518/621) для настройки Python-проектов.
# Здесь собраны конфигурации всех инструментов в одном месте.
#
# Преимущества единого файла:
#   - Все настройки в одном месте — легко найти и изменить
#   - TOML-формат читабельнее INI (setup.cfg) и JSON
#   - Поддерживается всеми современными инструментами
#   - Стандарт Python-сообщества с 2020 года


# ==============================================================================
# МЕТАДАННЫЕ ПРОЕКТА
# ==============================================================================
#
# Базовая информация о проекте. Нужна для:
#   - Документации (название, описание)
#   - Совместимости (версия Python)
#   - Возможного будущего пакетирования (pip install)

[project]
name = "unibot"
version = "0.1.0"
description = "Telegram-бот с доступом к AI-генерациям"
readme = "README.md"
license = {file = "LICENSE.md"}
authors = [
    {name = "ООО Универсус"}
]

# Минимальная версия Python.
# Синтаксис >=3.11 означает "3.11 или новее".
requires-python = ">=3.11"


# ==============================================================================
# RUFF — ЛИНТЕР И ФОРМАТТЕР
# ==============================================================================
#
# Ruff — сверхбыстрый линтер для Python, написанный на Rust.
# Заменяет сразу несколько инструментов: flake8, isort, black, pylint и другие.
#
# Почему Ruff:
#   - В 10-100 раз быстрее аналогов (проверяет код за миллисекунды)
#   - Автоматически исправляет ошибки (--fix)
#   - Один инструмент вместо 5-6 разных
#
# Документация: https://docs.astral.sh/ruff

[tool.ruff]
# Целевая версия Python — от этого зависят проверки синтаксиса.
# py311 = Python 3.11. Ruff будет предупреждать о несовместимом коде.
target-version = "py311"

# Максимальная длина строки в символах.
# 88 — стандарт Black (и Ruff). Немного длиннее PEP8 (79), но удобнее.
# Почему не 79: современные мониторы широкие, 79 символов — это 1970-е.
# Почему не 120: слишком длинные строки сложно читать.
line-length = 88

# Какие папки исключить из проверки.
# .venv — виртуальное окружение (чужой код, не наш)
# __pycache__ — скомпилированные файлы Python
# .git — служебные файлы Git
exclude = [
    ".venv",
    "__pycache__",
    ".git",
]


[tool.ruff.lint]
# ==============================================================================
# ОСНОВНЫЕ ПРАВИЛА (БАЗОВЫЙ НАБОР)
# ==============================================================================
#
# Каждая буква/аббревиатура — группа правил от разных linter-ов.
# Ruff объединяет 50+ инструментов в один быстрый линтер.
#
#   E, W — pycodestyle (стиль кода по PEP8)
#          E = ошибки, W = предупреждения
#          Примеры: лишние пробелы, неправильные отступы
#
#   F — Pyflakes (логические ошибки)
#       Примеры: неиспользуемые импорты, undefined переменные
#
#   I — isort (сортировка импортов)
#       Автоматически группирует и сортирует import/from
#
#   UP — pyupgrade (модернизация кода)
#        Заменяет устаревший синтаксис на современный
#        Пример: dict() → {}, "{}".format(x) → f"{x}"
#
#   B — flake8-bugbear (потенциальные баги)
#       Находит подозрительный код, который может быть ошибкой
#
#   S — flake8-bandit (безопасность)
#       Находит уязвимости: SQL-инъекции, небезопасные функции
#
#   RUF — правила самого Ruff
#         Дополнительные проверки от авторов Ruff
#
#   C4 — flake8-comprehensions (оптимизация comprehensions)
#        Предлагает заменить list(x for ...) на [x for ...]
#        Делает код быстрее и читабельнее
#
#   SIM — flake8-simplify (упрощение кода)
#         Находит избыточные конструкции: if x == True → if x
#         Предлагает тернарные операторы вместо if/else
#
#   PIE — flake8-pie (плохие практики)
#         Находит антипаттерны: pass в функциях, ненужные spread-операторы
#
#   PT — flake8-pytest-style (стиль pytest)
#        Проверяет правильное использование pytest: фикстуры, marks, raises
#
#   ERA — eradicate (закомментированный код)
#         Находит и помечает закомментированный код для удаления.
#         Закомментированный код — это технический долг, его нужно удалять.
#
# ==============================================================================
# ПРАВИЛА ДЛЯ ASYNC/FASTAPI (КРИТИЧЕСКИ ВАЖНО!)
# ==============================================================================
#
#   ASYNC — flake8-async (проблемы в async коде)
#           ASYNC100: отмена без checkpoint
#           ASYNC109: async функция с timeout параметром (антипаттерн)
#           ASYNC110: busy wait в async (while True: await sleep)
#           ASYNC115: asyncio.sleep(0) — лучше asyncio.sleep(0) → yield
#           Критично для aiogram/FastAPI — находит блокирующие вызовы!
#
#   FAST — FastAPI-специфичные правила
#          FAST001: избыточный response_model (уже указан в аннотации)
#          FAST002: dependency без Annotated (устаревший стиль)
#          FAST003: неиспользуемый path parameter
#
# ==============================================================================
# ПРАВИЛА КАЧЕСТВА КОДА
# ==============================================================================
#
#   TRY — tryceratops (обработка исключений)
#         TRY003: длинные сообщения в raise (выноси в переменную)
#         TRY004: prefer TypeError для проверки типов
#         TRY201: raise без re-raise в except
#         TRY301: raise в try блоке (антипаттерн)
#         TRY400: logging.error вместо logging.exception
#
#   RET — flake8-return (правила для return)
#         RET501: не возвращай None явно, если можно опустить
#         RET502: return None в конце функции — избыточен
#         RET503: отсутствует return в конце ветки
#         RET504: ненужное присваивание перед return
#         RET505: ненужный else после return
#
#   ARG — flake8-unused-arguments (неиспользуемые аргументы)
#         ARG001: неиспользуемый аргумент функции
#         ARG002: неиспользуемый аргумент метода
#         ARG005: неиспользуемый lambda аргумент
#         Помогает найти мёртвый код и ошибки в сигнатурах
#
#   PERF — Perflint (производительность)
#          PERF101: ненужный list() вокруг итератора
#          PERF102: ключи словаря уже итерируемы (dict.keys())
#          PERF401: list comprehension вместо manual append
#          PERF402: list copy вместо list()
#
#   BLE — flake8-blind-except (слепые except)
#         BLE001: не используй голый except: или except Exception:
#         Всегда ловите конкретные исключения!
#
#   RSE — flake8-raise (правила для raise)
#         RSE102: ненужные скобки в raise
#
#   FURB — refurb (современный Python)
#          Предлагает современные конструкции Python 3.10+
#          Например: match вместо цепочки if/elif
#
# ==============================================================================
# ПРАВИЛА ЛОГИРОВАНИЯ
# ==============================================================================
#
#   G — flake8-logging-format (формат логов)
#       G001: не используй str.format() в логах
#       G002: не используй % форматирование в логах
#       G003: не используй + конкатенацию в логах
#       G004: не используй f-strings в логах!
#       ПОЧЕМУ: lazy evaluation — если уровень лога отключён,
#       форматирование не выполняется. С f-string оно ВСЕГДА выполняется.
#       Правильно: logger.info("User %s logged in", user_id)
#       Неправильно: logger.info(f"User {user_id} logged in")
#
#   LOG — flake8-logging (дополнительные правила логов)
#         LOG001: прямой вызов logging.* вместо logger.*
#         LOG002: невалидный уровень логирования
#         LOG004: exception() вне except блока
#
# ==============================================================================
# ПРАВИЛА БЕЗОПАСНОСТИ И ТИПОВ
# ==============================================================================
#
#   A — flake8-builtins (защита встроенных функций)
#       A001: не переопределяй встроенные (list, id, type, input, open)
#       A002: не используй встроенные как аргументы
#       A003: не используй встроенные как атрибуты класса
#
#   DTZ — flake8-datetimez (безопасная работа с датами)
#         DTZ001: datetime.now() без timezone — опасно!
#         DTZ002: datetime.today() без timezone — опасно!
#         DTZ003: datetime.utcnow() — deprecated, используй datetime.now(UTC)
#         DTZ005: datetime.now() — всегда указывай tz=
#         Timezone-naive даты — источник багов в production!
#
#   TC — flake8-type-checking (оптимизация импортов)
#        TC001: импорт только для аннотаций — вынеси в TYPE_CHECKING
#        TC002: импорт из typing для runtime — можно упростить
#        Ускоряет старт приложения, уменьшает циклические импорты.
#
#   N — pep8-naming (правила именования)
#       N801: имена классов в CamelCase
#       N802: имена функций в snake_case
#       N803: имена аргументов в snake_case
#       N806: переменные в функциях — snake_case
#
# ==============================================================================
# ПРАВИЛА СТИЛЯ КОДА
# ==============================================================================
#
#   T20 — flake8-print (запрет print)
#         T201: print() найден — используй logging!
#         T203: pprint() найден — используй logging!
#         В production коде print() — это антипаттерн.
#
#   PTH — flake8-use-pathlib (предпочитай pathlib)
#         PTH100: os.path.abspath → Path.resolve()
#         PTH103: os.makedirs → Path.mkdir()
#         PTH110: os.path.exists → Path.exists()
#         PTH123: open() → Path.open()
#         pathlib — более современный и читаемый API.
#
#   EM — flake8-errmsg (сообщения исключений)
#        EM101: строковый литерал в raise — выноси в переменную
#        EM102: f-string в raise — выноси в переменную
#        EM103: .format() в raise — выноси в переменную
#        Улучшает читаемость traceback и тестируемость.
#
select = [
    # Базовые правила (стиль, ошибки, импорты)
    "E", "W", "F", "I", "UP", "B", "S", "RUF",
    # Улучшение кода (comprehensions, simplify, bad practices)
    "C4", "SIM", "PIE",
    # Тестирование
    "PT",
    # Технический долг
    "ERA",
    # Async/FastAPI — КРИТИЧНО для нашего стека!
    "ASYNC", "FAST",
    # Качество кода
    "TRY", "RET", "ARG", "PERF", "BLE", "RSE", "FURB",
    # Логирование
    "G", "LOG",
    # Безопасность и типы
    "A", "DTZ", "TC", "N",
    # Стиль
    "T20", "PTH", "EM",
]

# Дополнительные правила сложности кода.
# Эти правила ЗАСТАВЛЯЮТ рефакторить сложные функции!
#
#   C90 — McCabe complexity (цикломатическая сложность)
#         Считает количество путей выполнения в функции.
#         Если сложность >10 — функцию нужно разбить на части.
#
#   PLR0912 — Too many branches (слишком много веток)
#             Если в функции >12 веток if/elif/else — рефакторить.
#             Совет: используйте словари, паттерн "стратегия", early return.
#
#   PLR0913 — Too many arguments (слишком много аргументов)
#             Если у функции >5 аргументов — рефакторить.
#             Совет: сгруппируйте аргументы в dataclass или Pydantic-модель.
#
#   PLR0915 — Too many statements (слишком много строк)
#             Если в функции >50 statements — рефакторить.
#             Совет: выделите логические блоки в отдельные функции.
#
extend-select = ["C90", "PLR0912", "PLR0913", "PLR0915"]

# ==============================================================================
# ИГНОРИРУЕМЫЕ ПРАВИЛА
# ==============================================================================
#
# Некоторые правила слишком строгие или не подходят для нашего проекта.
#
#   S101 — использование assert
#          В тестах assert — это нормально, не нужно предупреждать.
#
#   S104 — привязка к 0.0.0.0
#          Для Docker/production это нормально.
#
#   RUF001, RUF002, RUF003 — "неоднозначные" Unicode-символы
#          Ruff думает, что кириллица — это опечатка (с вместо c, о вместо o).
#          Но у нас весь проект на русском языке, поэтому отключаем.
#          RUF001 = строки, RUF002 = docstrings, RUF003 = комментарии
#
#   TRY003 — длинные сообщения в исключениях
#            Иногда нужны подробные сообщения для пользователей.
#
#   EM101, EM102 — строки в raise
#                  Для простых случаев это нормально.
#
#   DTZ011 — datetime.today() без tz
#            У нас есть случаи, где timezone не критичен (логи).
#
#   ARG001, ARG002 — неиспользуемые аргументы
#                    В хендлерах aiogram часто нужны аргументы для сигнатуры,
#                    даже если они не используются.
#
#   N818 — исключения должны заканчиваться на Error
#          Не все исключения — ошибки (например, StopIteration).
#
ignore = [
    # Безопасность
    "S101",    # assert — нужен в тестах
    "S104",    # 0.0.0.0 — нужен для Docker

    # Кириллица (русский язык в проекте)
    "RUF001",  # кириллица в строках
    "RUF002",  # кириллица в docstrings
    "RUF003",  # кириллица в комментариях

    # Сообщения исключений (иногда нужны подробные)
    "TRY003",  # длинные сообщения в raise
    "EM101",   # строковый литерал в raise
    "EM102",   # f-string в raise

    # Неиспользуемые аргументы (aiogram хендлеры требуют сигнатуру)
    "ARG001",  # неиспользуемый аргумент функции
    "ARG002",  # неиспользуемый аргумент метода

    # Именование
    "N818",    # исключения без суффикса Error

    # Спорные правила tryceratops — текущий стиль читабельнее
    "TRY300",  # return в try вместо else — часто читабельнее без else
    "TRY301",  # raise в try — иногда нужен для обёртки ошибок
    "TRY400",  # logging.exception вместо logging.error — иногда error читабельнее

    # Спорные правила return
    "RET505",  # elif после return — читабельнее для match-like паттернов

    # Закомментированный код — слишком много ложных срабатываний
    # ERA думает, что комментарии с двоеточием — это код
    "ERA001",  # commented-out code
]

# Какие ошибки исправлять автоматически при запуске ruff check --fix
fixable = ["ALL"]

# Разрешить неиспользуемые переменные с префиксом _
# Это стандартная практика Python: _unused_var означает "я знаю, что не использую"
dummy-variable-rgx = "^(_+|(_+[a-zA-Z0-9_]*[a-zA-Z0-9]+?))$"

# ==============================================================================
# НАСТРОЙКИ ДЛЯ РАЗНЫХ ТИПОВ ФАЙЛОВ
# ==============================================================================
#
# Разные типы файлов имеют разные требования.
# Тесты — особый случай: там нужны assert, магические числа, много фикстур.

[tool.ruff.lint.per-file-ignores]
# В тестах разрешаем:
#   PLR2004 — магические числа (в тестах часто нужны конкретные значения: 42, 100)
#   PLR0913 — много аргументов (фикстуры pytest могут требовать много параметров)
#   S101 — assert (это основа pytest, без него никуда)
#   ARG001, ARG002 — неиспользуемые аргументы (фикстуры часто не используются напрямую)
#   DTZ001, DTZ005 — datetime без timezone (в тестах не критично)
"tests/*" = ["PLR2004", "PLR0913", "S101", "ARG001", "ARG002", "DTZ001", "DTZ005", "SIM117"]

# Обработчики команд — сложность выше 10 из-за множества except-блоков
# и интеграции биллинга.
# Это стандартный паттерн для aiogram handlers: разные типы ошибок требуют
# разной обработки (UserNotFoundError, GenerationError, DatabaseError, Exception).
# Плюс добавлена логика биллинга (check_and_reserve, charge_generation).
# Рефакторинг усложнит читаемость кода.
#   C901 — McCabe complexity (цикломатическая сложность)
#   PLR0912 — Too many branches (ветки if/elif/else)
#   PLR0915 — Too many statements (строк в функции)
"src/bot/handlers/chatgpt.py" = ["C901", "PLR0912", "PLR0915"]
"src/bot/handlers/start.py" = ["C901", "PLR0912"]
"src/bot/handlers/imagine.py" = ["C901", "PLR0915"]
"src/bot/handlers/edit_image.py" = ["C901"]

# В миграциях Alembic игнорируем большинство правил
# (это автогенерированный код, его не нужно линтить)
"alembic/*" = ["ALL"]

# SQLAdmin views — требует сигнатуру lambda m, a: где a не используется
"src/admin/*" = ["ARG005"]

# Репозитории рассылок — много параметров для сегментации получателей
# Это стандартный API паттерн: явные фильтры вместо словаря **kwargs
"src/db/repositories/broadcast_repo.py" = ["PLR0913"]
"src/db/repositories/user_repo.py" = ["PLR0913"]
"src/services/broadcast_service.py" = ["PLR0913"]

# Settings — print() используется ДО инициализации logging
# Это единственное место, где print() оправдан
"src/config/settings.py" = ["T201"]

# Logging utils — formatTime это override метода logging.Formatter
# Имя нельзя менять, оно задано родительским классом
"src/utils/logging.py" = ["N802"]

# ==============================================================================
# НАСТРОЙКИ ОТДЕЛЬНЫХ LINTER-ОВ
# ==============================================================================

# Настройка сортировки импортов (isort).
# known-first-party — список наших модулей, чтобы isort группировал их отдельно.
# Это создаёт три группы: стандартная библиотека, внешние пакеты, наш код.
[tool.ruff.lint.isort]
known-first-party = ["src"]

# Настройка проверки сложности кода.
# max-complexity = 10 — стандартное значение.
# Если сложность выше — функция слишком запутанная, нужно рефакторить.
#
# Цикломатическая сложность = количество независимых путей в коде.
# Каждый if/elif/for/while/except добавляет +1 к сложности.
# Сложность 10 означает максимум ~10 ветвлений в функции.
[tool.ruff.lint.mccabe]
max-complexity = 10

# Настройки для flake8-type-checking.
# exempt-modules — модули, которые можно импортировать в runtime
# (typing всегда нужен, pydantic использует типы в runtime).
[tool.ruff.lint.flake8-type-checking]
exempt-modules = ["typing", "typing_extensions", "pydantic"]

# Настройки для pep8-naming.
# Игнорируем некоторые паттерны именования.
[tool.ruff.lint.pep8-naming]
# Разрешаем имена с одной буквы в comprehensions и lambda
# Пример: [x for x in items], lambda x: x + 1
ignore-names = ["x", "y", "z", "i", "j", "k", "n", "m", "e", "f", "db"]

# Настройки для pylint.
# Устанавливаем разумные лимиты для правил сложности.
[tool.ruff.lint.pylint]
max-args = 6           # Максимум аргументов в функции (PLR0913)
max-branches = 12      # Максимум веток if/elif (PLR0912)
max-statements = 50    # Максимум строк в функции (PLR0915)
max-returns = 6        # Максимум return в функции


[tool.ruff.format]
# Стиль кавычек в строках.
# "double" — двойные кавычки "строка" (стандарт Black)
# "single" — одинарные 'строка' (стандарт JavaScript)
# Мы используем двойные — это стандарт Python-сообщества.
quote-style = "double"

# Стиль отступов.
# "space" — пробелы (стандарт Python, PEP8)
# "tab" — табуляция
# Python-сообщество использует 4 пробела для отступов.
indent-style = "space"


# ==============================================================================
# MYPY — ПРОВЕРКА ТИПОВ
# ==============================================================================
#
# Mypy — статический анализатор типов для Python.
# Проверяет, что типы переменных соответствуют аннотациям.
#
# Зачем это нужно:
#   - Находит ошибки ДО запуска программы (не в runtime)
#   - IDE показывает подсказки на основе типов
#   - Код становится самодокументируемым
#
# Пример ошибки, которую найдёт mypy:
#   def greet(name: str) -> str:
#       return "Hello, " + name
#   greet(123)  # mypy: Argument 1 has incompatible type "int"; expected "str"
#
# Документация: https://mypy.readthedocs.io

[tool.mypy]
# ==============================================================================
# БАЗОВЫЕ НАСТРОЙКИ
# ==============================================================================

# Версия Python для проверки типов.
# Должна совпадать с версией в проекте.
python_version = "3.11"

# Строгий режим — максимально строгая проверка типов.
# Включает ВСЕ проверки: требует аннотации везде, запрещает Any и т.д.
# Это сложнее, но код получается надёжнее.
#
# Что включает strict:
#   - disallow_untyped_defs: функции без аннотаций — ошибка
#   - disallow_incomplete_defs: неполные аннотации — ошибка
#   - disallow_untyped_calls: вызов untyped функций — ошибка
#   - disallow_untyped_decorators: untyped декораторы — ошибка
#   - disallow_any_generics: List вместо List[str] — ошибка
#   - disallow_subclassing_any: наследование от Any — ошибка
#   - warn_return_any: return с типом Any — предупреждение
#   - warn_unused_ignores: ненужные # type: ignore — предупреждение
#   - no_implicit_reexport: неявный реэкспорт — ошибка
#   - strict_equality: сравнение несовместимых типов — ошибка
strict = true

# Плагины для специальных библиотек.
# pydantic.mypy — плагин для Pydantic, чтобы mypy понимал модели.
# Без него mypy не знает, что BaseModel создаёт атрибуты из аннотаций.
plugins = ["pydantic.mypy"]

# ==============================================================================
# ДОПОЛНИТЕЛЬНЫЕ ПРЕДУПРЕЖДЕНИЯ
# ==============================================================================

# Предупреждать о ненужных cast().
# Если mypy уже знает тип — cast() избыточен.
warn_redundant_casts = true

# Предупреждать о ненужных # type: ignore.
# Если ошибки нет — зачем игнорировать?
# Помогает держать код в чистоте при обновлении mypy.
warn_unused_ignores = true

# Предупреждать о неиспользуемых [mypy] настройках в конфиге.
# Например, если модуль в overrides не существует.
warn_unused_configs = true

# ==============================================================================
# УЛУЧШЕННЫЙ ВЫВОД ОШИБОК
# ==============================================================================

# Показывать коды ошибок в сообщениях.
# Пример: error: ... [arg-type]
# Это упрощает поиск решений и точечное игнорирование.
show_error_codes = true

# Показывать номера колонок в ошибках.
# Помогает найти точное место ошибки в длинных строках.
show_column_numbers = true

# Красивый вывод с контекстом кода.
# Показывает фрагмент кода с указателем на ошибку.
# Делает сообщения mypy намного понятнее!
pretty = true

# Показывать контекст ошибки (в какой функции/классе).
# Полезно для понимания, откуда пришла ошибка.
show_error_context = true

# ==============================================================================
# ДОПОЛНИТЕЛЬНЫЕ ПРОВЕРКИ (error codes)
# ==============================================================================
#
# Эти проверки не включены в strict, но очень полезны.
# Особенно важны для async кода!

enable_error_code = [
    # КРИТИЧНО для async кода!
    # Находит неиспользуемые awaitable (забытый await).
    # Пример ошибки: asyncio.create_task(f()) без await или присваивания.
    "unused-awaitable",

    # Находит избыточные проверки типов.
    # Пример: if isinstance(x, int) когда x уже int.
    # Помогает упростить код.
    "redundant-expr",

    # Находит объекты без __bool__/__len__ в boolean контексте.
    # Пример: if my_object: — если объект всегда truthy, это баг.
    "truthy-bool",

    # Находит возможно неопределённые переменные.
    # Пример: if cond: x = 1; print(x) — x может быть не определён.
    "possibly-undefined",

    # Требует декоратор @override при переопределении методов родительского класса.
    # Пример: если родительский метод переименован — mypy покажет ошибку.
    # Защищает от случайного "отрыва" метода от родителя.
    # Используй: from typing import override (Python 3.12+) или typing_extensions.
    "explicit-override",

    # Требует указывать код ошибки в # type: ignore комментариях.
    # ПЛОХО:  x = foo()  # type: ignore
    # ХОРОШО: x = foo()  # type: ignore[arg-type]
    # Делает игнорирование точечным — игнорируется только конкретная ошибка.
    # При обновлении mypy новые ошибки не будут случайно скрыты.
    "ignore-without-code",

    # Находит небезопасное переопределение мутабельных атрибутов класса.
    # Пример: родитель имеет list, потомок переопределяет как tuple — нарушение LSP.
    # Помогает писать корректные иерархии классов.
    "mutable-override",
]

# ==============================================================================
# ИМПОРТЫ БЕЗ ТИПОВ
# ==============================================================================

# Игнорировать библиотеки без аннотаций типов.
# Многие библиотеки не имеют type hints — это нормально.
# Без этой опции mypy будет ругаться на каждый import.
#
# ВАЖНО: лучше использовать per-module overrides для конкретных библиотек,
# но для простоты включаем глобально.
ignore_missing_imports = true

# ==============================================================================
# НАСТРОЙКИ ДЛЯ КОНКРЕТНЫХ МОДУЛЕЙ
# ==============================================================================

# Настройки для модуля admin.
# SQLAdmin использует паттерны с динамическими атрибутами,
# которые mypy не может проверить корректно.
# Например: model = User (атрибут класса, который SQLAdmin использует магически).
#
# mutable-override: SQLAdmin объявляет column_list и т.д. как Sequence,
# но стандартный паттерн использования — list. Это безопасно, так как
# SQLAdmin только читает эти атрибуты, не модифицирует их.
[[tool.mypy.overrides]]
module = "src.admin.*"
disable_error_code = ["attr-defined", "mutable-override"]

# Специальные настройки для API endpoints.
# FastAPI декораторы (@router.get, @router.post) не имеют полных типов,
# что приводит к ошибке "Untyped decorator makes function untyped" [misc].
# Также typed_post() wrapper возвращает Any из-за ограничений FastAPI типизации.
# Отключаем эти проверки для API модулей.
[[tool.mypy.overrides]]
module = "src.api.*"
disable_error_code = ["misc", "no-any-return"]

# Специальные настройки для тестов.
# pytest.fixture и pytest.mark.asyncio декораторы не имеют полных типов,
# что приводит к ошибке "Untyped decorator makes function untyped".
# Также в тестах используются моки (MagicMock), которые mypy не распознаёт
# как динамические объекты, что вызывает ошибки attr-defined и method-assign.
# Отключаем эти проверки для тестовых файлов.
[[tool.mypy.overrides]]
module = "tests.*"
disable_error_code = ["misc", "attr-defined", "method-assign", "union-attr"]

# Настройки для Alembic миграций.
# Миграции — автогенерированный код, строгая проверка избыточна.
[[tool.mypy.overrides]]
module = "alembic.*"
ignore_errors = true


# ==============================================================================
# PYTEST — ТЕСТИРОВАНИЕ
# ==============================================================================
#
# Pytest — стандартный фреймворк для тестирования Python-кода.
# Проще и мощнее, чем встроенный unittest.
#
# Документация: https://docs.pytest.org

[tool.pytest.ini_options]
# Режим asyncio для тестирования асинхронного кода.
# "auto" — pytest-asyncio автоматически определяет async-тесты.
# Без этого пришлось бы писать @pytest.mark.asyncio на каждом тесте.
asyncio_mode = "auto"

# Где искать тесты.
# pytest будет искать файлы test_*.py в папке tests/.
testpaths = ["tests"]

# Дополнительные аргументы при запуске pytest.
# -v — verbose, показывать названия тестов
# --tb=short — короткий traceback при ошибках (не на 100 строк)
addopts = "-v --tb=short"


# ==============================================================================
# PYTEST-ASYNCIO — АСИНХРОННОЕ ТЕСТИРОВАНИЕ
# ==============================================================================
#
# Настройки для pytest-asyncio — плагина для тестирования async-кода.

[tool.pytest-asyncio]
# Режим работы с asyncio.
# "auto" — автоматически создаёт event loop для async-тестов.
mode = "auto"
